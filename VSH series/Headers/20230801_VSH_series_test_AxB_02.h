/*
20230801_VSH_series_test_AxB_02.h

vector product A cross B.

Both A and B are generated "in reverse" by getting some random coefficients with three decimal places in [0,1].
This ensures that all VSHs are considered when verifying the sums.
Coeffs randonly generated by Random_VSH_coeff_generator.py.
*/

//----- Coeffs of A -----

std::complex<double> A_r_ell_m_hardcoded( double ell, double m ){
	
	if( ( ell == 0 ) and ( m ==  0 ) ){ return std::complex<double> { 0.697, 0.741 }; }

	if( ( ell == 1 ) and ( m == -1 ) ){ return std::complex<double> { 0.967, 0.144 }; }
	if( ( ell == 1 ) and ( m ==  0 ) ){ return std::complex<double> { 0.682, 0.260 }; }
	if( ( ell == 1 ) and ( m ==  1 ) ){ return std::complex<double> { 0.681, 0.613 }; }

	if( ( ell == 2 ) and ( m == -2 ) ){ return std::complex<double> { 0.889, 0.745 }; }
	if( ( ell == 2 ) and ( m == -1 ) ){ return std::complex<double> { 0.675, 0.430 }; }
	if( ( ell == 2 ) and ( m ==  0 ) ){ return std::complex<double> { 0.952, 0.430 }; }
	if( ( ell == 2 ) and ( m ==  1 ) ){ return std::complex<double> { 0.816, 0.707 }; }
	if( ( ell == 2 ) and ( m ==  2 ) ){ return std::complex<double> { 0.111, 0.417 }; }

	if( ( ell == 3 ) and ( m == -3 ) ){ return std::complex<double> { 0.840, 0.559 }; }
	if( ( ell == 3 ) and ( m == -2 ) ){ return std::complex<double> { 0.687, 0.127 }; }
	if( ( ell == 3 ) and ( m == -1 ) ){ return std::complex<double> { 0.389, 0.295 }; }
	if( ( ell == 3 ) and ( m ==  0 ) ){ return std::complex<double> { 0.899, 0.621 }; }
	if( ( ell == 3 ) and ( m ==  1 ) ){ return std::complex<double> { 0.796, 0.735 }; }
	if( ( ell == 3 ) and ( m ==  2 ) ){ return std::complex<double> { 0.683, 0.976 }; }
	if( ( ell == 3 ) and ( m ==  3 ) ){ return std::complex<double> { 0.593, 0.489 }; }
	
	return 0;
}

std::complex<double> A_1_ell_m_hardcoded( double ell, double m ){
	
	if( ( ell == 0 ) and ( m ==  0 ) ){ return std::complex<double> { 0.435, 0.532 }; }

	if( ( ell == 1 ) and ( m == -1 ) ){ return std::complex<double> { 0.231, 0.083 }; }
	if( ( ell == 1 ) and ( m ==  0 ) ){ return std::complex<double> { 0.885, 0.213 }; }
	if( ( ell == 1 ) and ( m ==  1 ) ){ return std::complex<double> { 0.234, 0.258 }; }

	if( ( ell == 2 ) and ( m == -2 ) ){ return std::complex<double> { 0.864, 0.768 }; }
	if( ( ell == 2 ) and ( m == -1 ) ){ return std::complex<double> { 0.161, 0.790 }; }
	if( ( ell == 2 ) and ( m ==  0 ) ){ return std::complex<double> { 0.187, 0.542 }; }
	if( ( ell == 2 ) and ( m ==  1 ) ){ return std::complex<double> { 0.305, 0.032 }; }
	if( ( ell == 2 ) and ( m ==  2 ) ){ return std::complex<double> { 0.858, 0.073 }; }

	if( ( ell == 3 ) and ( m == -3 ) ){ return std::complex<double> { 0.643, 0.342 }; }
	if( ( ell == 3 ) and ( m == -2 ) ){ return std::complex<double> { 0.549, 0.646 }; }
	if( ( ell == 3 ) and ( m == -1 ) ){ return std::complex<double> { 0.503, 0.311 }; }
	if( ( ell == 3 ) and ( m ==  0 ) ){ return std::complex<double> { 0.843, 0.129 }; }
	if( ( ell == 3 ) and ( m ==  1 ) ){ return std::complex<double> { 0.572, 0.688 }; }
	if( ( ell == 3 ) and ( m ==  2 ) ){ return std::complex<double> { 0.475, 0.179 }; }
	if( ( ell == 3 ) and ( m ==  3 ) ){ return std::complex<double> { 0.414, 0.660 }; }
	
	return 0;
}

std::complex<double> A_2_ell_m_hardcoded( double ell, double m ){
	
	if( ( ell == 0 ) and ( m ==  0 ) ){ return std::complex<double> { 0.549, 0.606 }; }

	if( ( ell == 1 ) and ( m == -1 ) ){ return std::complex<double> { 0.557, 0.131 }; }
	if( ( ell == 1 ) and ( m ==  0 ) ){ return std::complex<double> { 0.519, 0.499 }; }
	if( ( ell == 1 ) and ( m ==  1 ) ){ return std::complex<double> { 0.175, 0.114 }; }

	if( ( ell == 2 ) and ( m == -2 ) ){ return std::complex<double> { 0.341, 0.037 }; }
	if( ( ell == 2 ) and ( m == -1 ) ){ return std::complex<double> { 0.866, 0.328 }; }
	if( ( ell == 2 ) and ( m ==  0 ) ){ return std::complex<double> { 0.010, 0.279 }; }
	if( ( ell == 2 ) and ( m ==  1 ) ){ return std::complex<double> { 0.567, 0.901 }; }
	if( ( ell == 2 ) and ( m ==  2 ) ){ return std::complex<double> { 0.023, 0.416 }; }

	if( ( ell == 3 ) and ( m == -3 ) ){ return std::complex<double> { 0.743, 0.829 }; }
	if( ( ell == 3 ) and ( m == -2 ) ){ return std::complex<double> { 0.262, 0.593 }; }
	if( ( ell == 3 ) and ( m == -1 ) ){ return std::complex<double> { 0.970, 0.822 }; }
	if( ( ell == 3 ) and ( m ==  0 ) ){ return std::complex<double> { 0.525, 0.736 }; }
	if( ( ell == 3 ) and ( m ==  1 ) ){ return std::complex<double> { 0.953, 0.562 }; }
	if( ( ell == 3 ) and ( m ==  2 ) ){ return std::complex<double> { 0.239, 0.435 }; }
	if( ( ell == 3 ) and ( m ==  3 ) ){ return std::complex<double> { 0.979, 0.259 }; }
	
	return 0;
}




//----- Coeffs of B -----

std::complex<double> B_r_ell_m_hardcoded( double ell, double m ){
	
	if( ( ell == 0 ) and ( m ==  0 ) ){ return std::complex<double> { 0.392, 0.206 }; }

	if( ( ell == 1 ) and ( m == -1 ) ){ return std::complex<double> { 0.180, 0.920 }; }
	if( ( ell == 1 ) and ( m ==  0 ) ){ return std::complex<double> { 0.496, 0.301 }; }
	if( ( ell == 1 ) and ( m ==  1 ) ){ return std::complex<double> { 0.591, 0.045 }; }

	if( ( ell == 2 ) and ( m == -2 ) ){ return std::complex<double> { 0.456, 0.235 }; }
	if( ( ell == 2 ) and ( m == -1 ) ){ return std::complex<double> { 0.751, 0.603 }; }
	if( ( ell == 2 ) and ( m ==  0 ) ){ return std::complex<double> { 0.930, 0.808 }; }
	if( ( ell == 2 ) and ( m ==  1 ) ){ return std::complex<double> { 0.153, 0.534 }; }
	if( ( ell == 2 ) and ( m ==  2 ) ){ return std::complex<double> { 0.850, 0.418 }; }

	if( ( ell == 3 ) and ( m == -3 ) ){ return std::complex<double> { 0.926, 0.978 }; }
	if( ( ell == 3 ) and ( m == -2 ) ){ return std::complex<double> { 0.289, 0.506 }; }
	if( ( ell == 3 ) and ( m == -1 ) ){ return std::complex<double> { 0.587, 0.475 }; }
	if( ( ell == 3 ) and ( m ==  0 ) ){ return std::complex<double> { 0.677, 0.379 }; }
	if( ( ell == 3 ) and ( m ==  1 ) ){ return std::complex<double> { 0.897, 0.024 }; }
	if( ( ell == 3 ) and ( m ==  2 ) ){ return std::complex<double> { 0.647, 0.249 }; }
	if( ( ell == 3 ) and ( m ==  3 ) ){ return std::complex<double> { 0.454, 0.244 }; }
	
	return 0;
}

std::complex<double> B_1_ell_m_hardcoded( double ell, double m ){
	
	if( ( ell == 0 ) and ( m ==  0 ) ){ return std::complex<double> { 0.903, 0.337 }; }

	if( ( ell == 1 ) and ( m == -1 ) ){ return std::complex<double> { 0.079, 0.206 }; }
	if( ( ell == 1 ) and ( m ==  0 ) ){ return std::complex<double> { 0.257, 0.651 }; }
	if( ( ell == 1 ) and ( m ==  1 ) ){ return std::complex<double> { 0.124, 0.112 }; }

	if( ( ell == 2 ) and ( m == -2 ) ){ return std::complex<double> { 0.990, 0.252 }; }
	if( ( ell == 2 ) and ( m == -1 ) ){ return std::complex<double> { 0.177, 0.625 }; }
	if( ( ell == 2 ) and ( m ==  0 ) ){ return std::complex<double> { 0.026, 0.666 }; }
	if( ( ell == 2 ) and ( m ==  1 ) ){ return std::complex<double> { 0.650, 0.407 }; }
	if( ( ell == 2 ) and ( m ==  2 ) ){ return std::complex<double> { 0.395, 0.662 }; }

	if( ( ell == 3 ) and ( m == -3 ) ){ return std::complex<double> { 0.379, 0.171 }; }
	if( ( ell == 3 ) and ( m == -2 ) ){ return std::complex<double> { 0.051, 0.524 }; }
	if( ( ell == 3 ) and ( m == -1 ) ){ return std::complex<double> { 0.417, 0.189 }; }
	if( ( ell == 3 ) and ( m ==  0 ) ){ return std::complex<double> { 0.503, 0.632 }; }
	if( ( ell == 3 ) and ( m ==  1 ) ){ return std::complex<double> { 0.132, 0.242 }; }
	if( ( ell == 3 ) and ( m ==  2 ) ){ return std::complex<double> { 0.745, 0.761 }; }
	if( ( ell == 3 ) and ( m ==  3 ) ){ return std::complex<double> { 0.115, 0.107 }; }
	
	return 0;
}

std::complex<double> B_2_ell_m_hardcoded( double ell, double m ){
	
	if( ( ell == 0 ) and ( m ==  0 ) ){ return std::complex<double> { 0.604, 0.258 }; }

	if( ( ell == 1 ) and ( m == -1 ) ){ return std::complex<double> { 0.432, 0.369 }; }
	if( ( ell == 1 ) and ( m ==  0 ) ){ return std::complex<double> { 0.016, 0.039 }; }
	if( ( ell == 1 ) and ( m ==  1 ) ){ return std::complex<double> { 0.101, 0.058 }; }

	if( ( ell == 2 ) and ( m == -2 ) ){ return std::complex<double> { 0.730, 0.777 }; }
	if( ( ell == 2 ) and ( m == -1 ) ){ return std::complex<double> { 0.679, 0.432 }; }
	if( ( ell == 2 ) and ( m ==  0 ) ){ return std::complex<double> { 0.027, 0.081 }; }
	if( ( ell == 2 ) and ( m ==  1 ) ){ return std::complex<double> { 0.412, 0.422 }; }
	if( ( ell == 2 ) and ( m ==  2 ) ){ return std::complex<double> { 0.958, 0.388 }; }

	if( ( ell == 3 ) and ( m == -3 ) ){ return std::complex<double> { 0.583, 0.333 }; }
	if( ( ell == 3 ) and ( m == -2 ) ){ return std::complex<double> { 0.714, 0.967 }; }
	if( ( ell == 3 ) and ( m == -1 ) ){ return std::complex<double> { 0.520, 0.058 }; }
	if( ( ell == 3 ) and ( m ==  0 ) ){ return std::complex<double> { 0.550, 0.535 }; }
	if( ( ell == 3 ) and ( m ==  1 ) ){ return std::complex<double> { 0.383, 0.341 }; }
	if( ( ell == 3 ) and ( m ==  2 ) ){ return std::complex<double> { 0.601, 0.798 }; }
	if( ( ell == 3 ) and ( m ==  3 ) ){ return std::complex<double> { 0.654, 0.599 }; }
	
	return 0;
}


//----- Vector components of A -----

std::complex<double> A_r_function( double r, double theta, double phi ){
	
	std::complex<double> ret = 0;
	
	for( int ell=0; ell<=3; ell++ ){
		for( int m=-ell; m<=ell; m++ ){
			ret += VSH_Y( theta, phi, ell, m )[0] * A_r_ell_m_hardcoded( ell, m );
		}
	}
	
	return ret;
}

std::complex<double> A_theta_function( double r, double theta, double phi ){
	
	std::complex<double> ret = 0;
	
	for( int ell=1; ell<=3; ell++ ){
		for( int m=-ell; m<=ell; m++ ){
			ret += VSH_Psi( theta, phi, ell, m )[1] * A_1_ell_m_hardcoded( ell, m );
			ret += VSH_Phi( theta, phi, ell, m )[1] * A_2_ell_m_hardcoded( ell, m );
		}
	}
	
	return ret;
}

std::complex<double> A_phi_function( double r, double theta, double phi ){
	
	std::complex<double> ret = 0;
	
	for( int ell=1; ell<=3; ell++ ){
		for( int m=-ell; m<=ell; m++ ){
			ret += VSH_Psi( theta, phi, ell, m )[2] * A_1_ell_m_hardcoded( ell, m );
			ret += VSH_Phi( theta, phi, ell, m )[2] * A_2_ell_m_hardcoded( ell, m );
		}
	}
	
	return ret;
	
}



//----- Vector components of B -----

std::complex<double> B_r_function( double r, double theta, double phi ){
	
	std::complex<double> ret = 0;
	
	for( int ell=0; ell<=3; ell++ ){
		for( int m=-ell; m<=ell; m++ ){
			ret += VSH_Y( theta, phi, ell, m )[0] * B_r_ell_m_hardcoded( ell, m );
		}
	}
	
	return ret;
}

std::complex<double> B_theta_function( double r, double theta, double phi ){
	
	std::complex<double> ret = 0;
	
	for( int ell=1; ell<=3; ell++ ){
		for( int m=-ell; m<=ell; m++ ){
			ret += VSH_Psi( theta, phi, ell, m )[1] * B_1_ell_m_hardcoded( ell, m );
			ret += VSH_Phi( theta, phi, ell, m )[1] * B_2_ell_m_hardcoded( ell, m );
		}
	}
	
	return ret;
}

std::complex<double> B_phi_function( double r, double theta, double phi ){
	
	std::complex<double> ret = 0;
	
	for( int ell=1; ell<=3; ell++ ){
		for( int m=-ell; m<=ell; m++ ){
			ret += VSH_Psi( theta, phi, ell, m )[2] * B_1_ell_m_hardcoded( ell, m );
			ret += VSH_Phi( theta, phi, ell, m )[2] * B_2_ell_m_hardcoded( ell, m );
		}
	}
	
	return ret;
}