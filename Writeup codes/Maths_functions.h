/*
Maths_functions.h

Basic implementations of the mathematical functions described in the thesis, for demonstrative purposes.
One can easily produce more efficient formulations and those which are less susceptible to integer overflow.
This is primarily intended to be a quick example code demonstrating how to encode the functions used in the thesis, in a way relatively independent of the coding language.

The usefulness of e.g. the defined factorial function here will depend on your version of C++. Integer overflows will cause n! to become inaccurate above a certain n.
Run the following code snippet to find the maximum integers your version of C++ can produce:
std::cout << INT_MAX <<"\t"<< LONG_MAX <<"\t"<< LLONG_MAX << std::endl;
INT_MAX is the highest value of "int". LONG_MAX is the highest "long int". LLONG_MAX is the highest "long long int".
For the author, INT_MAX = LONG_MAX = 2147483647 = 2^(31) - 1 and LLONG_MAX = 9223372036854775807 = 2^(63) - 1. In this case, "int" and "long int" produce accurate foctorials up to 12! and "long long int" produces accurate factorials up to 20!.

*/

#include <math.h>
#include <complex>
#include <vector>
#include <iostream> // std::cout, std::endl
#include <iomanip> // std::left, std::setw

const double pi = acos( -1 );

double P_ell( double x, int ell ){
	// Legendre polynomial P_ell(x). Generated by Bonnet's recursion relation.
	
	if( ell == 0 ){
		return 1.0;
	}
	if( ell == 1 ){
		return x;
	}
	
	double P_L_minus_2 = 1.0;
	double P_L_minus_1 = x;
	double P_L         = 1.0;	// Result to calculate.
	
	for( int L=2; L<=ell; L++ ){
		P_L = ( ( 2.0 * L - 1.0 ) * x * P_L_minus_1 - ( L - 1.0 ) * P_L_minus_2 ) / ( (double) L );
		P_L_minus_2 = P_L_minus_1;
		P_L_minus_1 = P_L;
	}
	
	return P_L;
	
}




long long int factorial( int n ){
	// Factorial of a number n, n!.
	
	long long int ret = 1;		// Value to return.
	
	for( int k=1; k<=n; k++ ){
		ret *= k;
	}
	
	return ret;
	
}




long long int double_factorial( int n ){
	// Double-factorial of a number n, n!!.
	
	long long int ret = 1;				// Value to return.
	int k0 = ( n % 2 == 0 ) ? 2 : 1;	// If n even, start from k=2. Else, start from k=1.
	
	for( int k=k0; k<=n; k+=2 ){
		ret *= k;
	}
	
	return ret;
	
}





double P_ell_m( double x, int ell, int m ){
	// Associated Legendre function P_ell^m(x). Generated by generalised Bonnet recursion relation.
	// Returns 0 if |m| > ell, which is useful when being called by other functions e.g. Y_ell_m_dtheta().
	
	if( abs(m) > ell ){
		return 0;
	}
	
	int M = abs( m );
	
	double P_Lminus2_M = pow( -1, M ) * double_factorial( 2*M - 1 ) * pow( 1-x*x, (double)0.5*M );	// P_M^M(x)
	double P_Lminus1_M = ( 2*M + 1 ) * x * P_Lminus2_M;												// P_{M+1}^M(x)
	double P_L_m       = 1.0;																		// P_L^m(x). To calculate.
	
	double minus_factor = ( m < 0 ) ? ( pow( -1, M ) * factorial( ell - M ) / ( (long double) factorial( ell + M ) ) ) : 1.0;	// To account for negative index m.
	
	if( ell == M ){
		return P_Lminus2_M * minus_factor;
	}
	if( ell == M+1 ){
		return P_Lminus1_M * minus_factor;
	}
	
	for( int L=M+2; L<=ell; L++ ){
		P_L_m = ( ( 2 * L - 1.0 ) * x * P_Lminus1_M - ( L + M - 1.0 ) * P_Lminus2_M ) / ( (double) L - M );
		P_Lminus2_M = P_Lminus1_M;
		P_Lminus1_M = P_L_m;
	}
	
	return P_L_m * minus_factor;
	
}




std::complex<double> Y_ell_m( double theta, double phi, int ell, int m ){
	// Spherical harmonic Y_ell^m( theta, phi ). Calls the previously defined associated Legendre function expression.
	
	return pow( ( 2.0 * ell + 1.0 ) * factorial( ell - m ) / ( 4.0 * pi * factorial( ell + m ) ), 0.5 )
	       * P_ell_m( cos(theta), ell, m )
		   * exp( std::complex<double> { 0, m * phi } );
		   
}




std::complex<double> Y_ell_m_dtheta( double theta, double phi, int ell, int m ){
	// First theta-derivative of spherical harmonic partial/partial theta( Y_ell^m( theta, phi ) ). Calls Y_ell_m for different values of m.
	
	return 0.5 * (   sqrt( ( ell - m ) * ( ell + m + 1 ) ) * Y_ell_m( theta, phi, ell, m+1 ) * exp( std::complex<double> { 0, -phi } )
	               - sqrt( ( ell + m ) * ( ell - m + 1 ) ) * Y_ell_m( theta, phi, ell, m-1 ) * exp( std::complex<double> { 0,  phi } ) );
				   
}




std::complex<double> Y_ell_m_dphi_over_sintheta( double theta, double phi, int ell, int m ){
	// 1/sin(theta) partial/partial phi( Y_ell^m( theta, phi ) ). Calls Y_ell_m for different values of m.
	
	return (   sqrt( ( ell + m + 2 ) * ( ell + m + 1 ) ) * Y_ell_m( theta, phi, ell+1, m+1 ) * exp( std::complex<double> { 0, -phi } )
	         + sqrt( ( ell - m + 2 ) * ( ell - m + 1 ) ) * Y_ell_m( theta, phi, ell+1, m-1 ) * exp( std::complex<double> { 0,  phi } ) )
		   * std::complex<double> { 0, -0.5 * sqrt( ( 2.0 * ell + 1.0 ) / ( 2.0 * ell + 3.0 ) ) };
				   
}




void print_vector( std::vector< std::complex<double> > v ){
	// Print the components of a vector v to the screen, separated by tabs.
	
	for( int i=0; i<v.size()-1; i++ ){
		std::cout << std::left << std::setw( 25 ) << v[i];
	}
	
	std::cout << v.back() << std::endl;
	
}




std::vector< std::complex<double> > VSH_Y( double theta, double phi, int ell, int m ){
	// Vector spherical harmonic Y_ell^m. Calls Y_ell_m.
	
	return std::vector< std::complex<double> > {
		Y_ell_m( theta, phi, ell, m ),
		0,
		0
	};
	
}




std::vector< std::complex<double> > VSH_Psi( double theta, double phi, int ell, int m ){
	// Vector spherical harmonic Psi_ell^m. Calls Y_ell_m, Y_ell_m_dtheta and Y_ell_m_dphi_over_sintheta.
	
	return std::vector< std::complex<double> > {
		0,
		Y_ell_m_dtheta( theta, phi, ell, m ),
		Y_ell_m_dphi_over_sintheta( theta, phi, ell, m )
	};
	
}




std::vector< std::complex<double> > VSH_Phi( double theta, double phi, int ell, int m ){
	// Vector spherical harmonic Phi_ell^m. Calls Y_ell_m, Y_ell_m_dtheta and Y_ell_m_dphi_over_sintheta.
	
	return std::vector< std::complex<double> > {
		0,
		- Y_ell_m_dphi_over_sintheta( theta, phi, ell, m ),
		Y_ell_m_dtheta( theta, phi, ell, m )
	};
	
}